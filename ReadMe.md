##1、熟练掌握单例模式的常见写法。
饿汉式、懒汉式、（懒汉）双重检查锁、内部类方式、注册式枚举、注册式容器缓存
##2、总结每种单例写法的优、缺点。
	
###饿汉式单例	
在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线
程还没出现以前就是实例化了，不可能存在访问安全问题。	没有加任何的锁、执行效率比较高；线程安全	不管是否使用，都占内存
###懒汉式单例	
被外部类调用的时候内部类才会加载	不浪费内存	不加锁线程不安全
###（懒汉）双重检查锁
为了解决懒汉式的线程安全问题，通过synchronized 关键字上锁	避免了懒汉式的线程安全问题	上锁会降低程序性能
###内部类方式	
兼顾饿汉式的内存浪费，也兼顾synchronized 性能问题。
内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题	兼顾饿汉式的内存浪费，也兼顾synchronized 性能问题	
###注册式枚举	
自由序列化、反射无法破坏、线程安全		
###容器缓存单例		
方便管理大量单例	线程不安全


##3、思考破坏单例模式的方式有哪些？并且归纳总结。
###破坏单例模式的方式有：序列化破坏、反射破坏。
####1）序列化破坏：
单例对象，进行序列化后转换为字节码形式。通过IO流写入磁盘或网络IO；当需要读取的时候，进行反序列化将字节码转为IO流，通过IO流读取内容转为java对象。反序列化的时候会重新new一个对象，而反序列化后的对象，和序列化之前的对象，不是同一个。如果序列化的目标对象是单例对象，那就是破坏了单例。
####2）反射破坏：
使用反射来调用其构造方法，然后，再调用getInstance()方法，就会
两个不同的实例。
//很无聊的情况下，进行破坏
Class<LazyInnerClassSingleton> clazz = LazyInnerClassSingleton.class;
//通过反射拿到私有的构造方法
Constructor<LazyInnerClassSingleton> c = clazz.getDeclaredConstructor(null);
//强制访问，强吻，不愿意也要吻
c.setAccessible(true);

//暴力初始化
LazyInnerClassSingleton o1 = c.newInstance();
//调用了两次构造方法，相当于new 了两次
//犯了原则性问题，
LazyInnerClassSingleton o2 = c.newInstance();
System.out.println(o1==o2);
###3）防止序列化破坏单例：
（1）可以加这句代码：
//为了解决序列化破坏单利，而加的
private Object readResolve(){
    return INSTANCE;
}
而这种方式：实际上也是将对象实例化了两次，只是第二次没有被返回。若创建对象很频繁，意味着内存分配开销也将增大！注册式单例可以解决这个问题：
###（2）防止反射破坏单例：
在内部类方式单例中，加上这个判断。
private LazyInnerClassSingletonLast (){
    if(LazyHolder.LAZY != null){
        throw new RuntimeException("不允许创建多个实例");
    }
}
当创建另外的实例时，将会抛出异常！
###（3）注册式单例：
可以防止序列化和反射破坏单例
枚举、容器缓存。
##4、梳理内部类的执行逻辑，并画出时序图。

时序图见根目录jpg

